package com.intranet.service.report;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import com.intranet.entity.TimeSheet;
import com.intranet.entity.TimeSheetEntry;
import com.intranet.repository.TimeSheetRepo;
import com.intranet.service.HolidayExcludeUsersService;
import com.intranet.util.cache.ProjectDirectoryService;
import com.intranet.util.cache.UserDirectoryService;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TimesheetFinanceReportService {


    @Value("${weekly_hours}")
    private int weeklyHours;

    private final TimeSheetRepo timeSheetRepo;
    private final HolidayExcludeUsersService holidayExcludeUsersService;
    private final UserDirectoryService userDirectoryService;
    private final ProjectDirectoryService projectDirectoryService;

    // ‚úÖ Authorization header builder
    private HttpEntity<Void> buildEntityWithAuth() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs == null) {
            return (HttpEntity<Void>) HttpEntity.EMPTY;
        }

        HttpServletRequest request = attrs.getRequest();
        String authHeader = request.getHeader("Authorization");

        HttpHeaders headers = new HttpHeaders();
        if (authHeader != null && !authHeader.isBlank()) {
            headers.set("Authorization", authHeader);
        }

        return new HttpEntity<>(headers);
    }

    public Map<String, Object> getTimesheetFinanceReport(int month, int year) {

        // Step 4Ô∏è‚É£: Get Auth Header and Fetch User Info Cache
        HttpEntity<Void> entity = buildEntityWithAuth();
        String authHeader = entity.getHeaders().getFirst("Authorization");
        Map<Long, Map<String, Object>> allUsers = userDirectoryService.fetchAllUsers(authHeader);
        Map<Long, Map<String, Object>> projectDirectory =
                projectDirectoryService.fetchAllProjects(authHeader);

        // ‚úÖ Step 1: Get holiday dates for users to exclude
        List<LocalDate> holidayDates = holidayExcludeUsersService.getUserHolidayDates(month);

        // ‚úÖ Step 2: Filter to only include holidays from this year
        holidayDates = holidayDates.stream()
                .filter(date -> date != null && date.getYear() == year)
                .toList();

        // ‚úÖ Step 2: Define current month range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());
        int totalDaysInMonth = firstDay.lengthOfMonth();

        // ‚úÖ Calculate working days
        int totalWorkingDays = totalDaysInMonth - holidayDates.size();
        
        // ‚úÖ Step 4: Fetch all timesheets for this month and year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay);

        // ‚úÖ Step 5: Filter strictly by same year (safety check)
        List<TimeSheet> currentYearTimeSheets = allTimeSheets.stream()
                .filter(ts -> ts.getWorkDate() != null && ts.getWorkDate().getYear() == year)
                .toList();

         // ‚úÖ Step 6: Calculate total hours (include auto-generated)
        BigDecimal totalHours = currentYearTimeSheets.stream()
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 7: Total Billable Hours (exclude auto-generated)
        BigDecimal totalBillableHours = currentYearTimeSheets.stream()
                .filter(ts -> !ts.getAutoGenerated()) // exclude system-generated
                .flatMap(ts -> ts.getEntries().stream())
                .filter(TimeSheetEntry::isBillable)
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 8: Total Non-Billable Hours (include auto-generated + non-billable entries)
        BigDecimal nonBillableFromEntries = currentYearTimeSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .filter(e -> !e.isBillable())
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal autoGeneratedHours = currentYearTimeSheets.stream()
                .filter(TimeSheet::getAutoGenerated)
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal totalNonBillableHours = nonBillableFromEntries.add(autoGeneratedHours); 

        // ‚úÖ Step 8: Calculate Utilization Rate = (Billable / Non-Billable) * 100
        BigDecimal utilizationRate = BigDecimal.ZERO;
        String utilizationRateStr = "0.00%";

        if (totalNonBillableHours.compareTo(BigDecimal.ZERO) > 0) {
            utilizationRate = totalBillableHours
                    .divide(totalHours, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100))
                    .setScale(2, RoundingMode.HALF_UP);

            utilizationRateStr = utilizationRate.toPlainString() + "%";
        }

        // 9. Hours Breakdown
        Map<String, Object> hoursBreakdown = new LinkedHashMap<>();
        hoursBreakdown.put("billableHours", totalBillableHours);
        hoursBreakdown.put("nonBillableHours", totalNonBillableHours);
        hoursBreakdown.put("leaveHours", 176);
        hoursBreakdown.put("totalHours", totalHours);
        
        // Step üîü: Build final response
        Map<String, Object> response = new LinkedHashMap<>();
        response.put("month", month);
        response.put("year", year);
        response.put("totalHolidayDates", holidayDates.size());
        response.put("totalWorkingDays", totalWorkingDays);
        response.put("holidayDates", holidayDates);
        response.put("totalHoursWorked", totalHours);
        response.put("totalBillableHours", totalBillableHours);
        response.put("totalNonBillableHours", totalNonBillableHours);
        response.put("utilizationRate", utilizationRateStr);
        response.put("hoursBreakdown", hoursBreakdown);
        response.put("employeeBreakdown", buildEmployeeBreakdown(month, year, allUsers));
        response.put("employeeProductivity", buildEmployeeProductivity(month, year, allUsers));
        response.put("projectBreakdown", buildProjectBreakdown(month, year, projectDirectory));
        response.put("projectUserHoursBreakdown",
                buildProjectUserHoursBreakdown(month, year, projectDirectory, allUsers));

        return response;
    }
    public List<Map<String, Object>> buildEmployeeBreakdown(int month, int year, Map<Long, Map<String, Object>> allUsers) {

        // Step 1Ô∏è‚É£: Define month range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all timesheets for the given month & year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .toList();

        // Step 3Ô∏è‚É£: Get unique user IDs
        Set<Long> userIds = allTimeSheets.stream()
                .map(TimeSheet::getUserId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        // Step 5Ô∏è‚É£: Prepare employee breakdown list
        List<Map<String, Object>> employeeBreakdown = new ArrayList<>();

        for (Long userId : userIds) {

            // Filter timesheets for this user in given month & year
            List<TimeSheet> userSheets = allTimeSheets.stream()
                    .filter(ts -> ts.getUserId().equals(userId) &&
                            ts.getWorkDate().getMonthValue() == month &&
                            ts.getWorkDate().getYear() == year)
                    .toList();

            // ‚úÖ Working Days (exclude auto-generated)
            long workingDays = userSheets.stream()
                    .filter(ts -> !ts.getAutoGenerated())
                    .map(TimeSheet::getWorkDate)
                    .distinct()
                    .count();

            // ‚úÖ Billable Hours (entries where isBillable = true)
            BigDecimal billableHours = userSheets.stream()
                    .filter(ts -> !ts.getAutoGenerated())
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(TimeSheetEntry::isBillable)
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Non-Billable Hours (entries where isBillable = false + auto-generated)
            BigDecimal nonBillableFromEntries = userSheets.stream()
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(e -> !e.isBillable())
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal autoGeneratedHours = userSheets.stream()
                    .filter(TimeSheet::getAutoGenerated)
                    .map(TimeSheet::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal nonBillableHours = nonBillableFromEntries.add(autoGeneratedHours);

            // ‚úÖ Leave Hours (fixed 8 for now)
            BigDecimal leaveHours = BigDecimal.valueOf(8);

            // ‚úÖ Total Hours = Billable + Non-Billable
            BigDecimal totalHours = billableHours.add(nonBillableHours);

            // ‚úÖ Productivity = (Billable / Total) * 100
            BigDecimal productivity = BigDecimal.ZERO;
            if (totalHours.compareTo(BigDecimal.ZERO) > 0) {
                productivity = billableHours
                        .divide(totalHours, 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                        .setScale(2, RoundingMode.HALF_UP);
            }

            // ‚úÖ Resolve name from UMS cache
            String name = Optional.ofNullable(allUsers.get(userId))
                    .map(u -> (String) u.get("name"))
                    .orElse("Unknown User");

            // ‚úÖ Build employee summary map
            Map<String, Object> emp = new LinkedHashMap<>();
            emp.put("name", name);
            emp.put("workingDays", workingDays);
            emp.put("billableHours", billableHours);
            emp.put("nonBillableHours", nonBillableHours);
            emp.put("leaveHours", leaveHours);
            emp.put("totalHours", totalHours);
            emp.put("productivity", productivity.toPlainString() + "%");

            employeeBreakdown.add(emp);
        }

        return employeeBreakdown;
    }
        public List<Map<String, Object>> buildEmployeeProductivity(int month, int year, Map<Long, Map<String, Object>> allUsers) {

        // Step 1Ô∏è‚É£: Define date range for month
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all timesheets for month and year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .toList();

        // Step 3Ô∏è‚É£: Get distinct user IDs
        Set<Long> userIds = allTimeSheets.stream()
                .map(TimeSheet::getUserId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        // Step 5Ô∏è‚É£: Build employee productivity details
        List<Map<String, Object>> productivityList = new ArrayList<>();

        for (Long userId : userIds) {

            List<TimeSheet> userSheets = allTimeSheets.stream()
                    .filter(ts -> ts.getUserId().equals(userId))
                    .toList();

            // ‚úÖ Working Days (exclude auto-generated)
            long workingDays = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .map(TimeSheet::getWorkDate)
                    .distinct()
                    .count();

            // ‚úÖ Billable Hours (exclude auto-generated)
            BigDecimal billableHours = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(TimeSheetEntry::isBillable)
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Non-Billable Hours (exclude auto-generated)
            BigDecimal nonBillableHours = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(e -> !e.isBillable())
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Auto-Generated Hours
            BigDecimal autoGeneratedHours = userSheets.stream()
                    .filter(TimeSheet::getAutoGenerated)
                    .map(TimeSheet::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Total Hours = billable + non-billable + auto-generated
            BigDecimal totalHours = billableHours.add(nonBillableHours).add(autoGeneratedHours);

            // ‚úÖ Productivity = (billable + non-billable) / 160 * 100
            BigDecimal productivity = BigDecimal.ZERO;
            if (billableHours.add(nonBillableHours).compareTo(BigDecimal.ZERO) > 0) {
                productivity = billableHours.add(nonBillableHours)
                        .divide(BigDecimal.valueOf(weeklyHours), 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                        .setScale(2, RoundingMode.HALF_UP);
            }

            // ‚úÖ Resolve employee name
            String name = Optional.ofNullable(allUsers.get(userId))
                    .map(u -> (String) u.get("name"))
                    .orElse("Unknown User");

            // ‚úÖ Build productivity record
            Map<String, Object> prod = new LinkedHashMap<>();
            prod.put("employeeId", userId);
            prod.put("employeeName", name);
            prod.put("workingDays", workingDays);
            prod.put("billableHours", billableHours);
            prod.put("nonBillableHours", nonBillableHours);
            prod.put("autoGeneratedHours", autoGeneratedHours);
            prod.put("totalHours", totalHours);
            prod.put("productivity", productivity.toPlainString() + "%");

            productivityList.add(prod);
        }

        return productivityList;
    }
        public List<Map<String, Object>> buildProjectBreakdown(int month, int year,Map<Long, Map<String, Object>> projectDirectory) {

        // Step 1Ô∏è‚É£: Define month date range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all timesheets for this month & year
        List<TimeSheet> monthSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                                ts.getWorkDate().getMonthValue() == month &&
                                ts.getWorkDate().getYear() == year)
                .filter(ts -> !ts.getAutoGenerated())  // exclude auto-generated
                .collect(Collectors.toList());

        // Step 3Ô∏è‚É£: Collect all entries for this month
        List<TimeSheetEntry> entries = monthSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .collect(Collectors.toList());

        // Step 4Ô∏è‚É£: Group entries by project ID
        Map<Long, List<TimeSheetEntry>> projectEntryMap = entries.stream()
                .filter(e -> e.getProjectId() != null)
                .collect(Collectors.groupingBy(TimeSheetEntry::getProjectId));

        // Step 6Ô∏è‚É£: Build final response list
        List<Map<String, Object>> projectBreakdown = new ArrayList<>();

        for (Map.Entry<Long, List<TimeSheetEntry>> entry : projectEntryMap.entrySet()) {

                Long projectId = entry.getKey();
                List<TimeSheetEntry> projectEntries = entry.getValue();

                // Skip if project metadata not found
                Map<String, Object> projectInfo = projectDirectory.get(projectId);
                if (projectInfo == null) {
                continue;  // Or add "Unknown Project"
                }

                // Extract project name
                String projectName = (String) projectInfo.getOrDefault("name", "Unknown Project");

                // Extract team member count
                List<Map<String, Object>> members =
                        (List<Map<String, Object>>) projectInfo.getOrDefault("members", Collections.emptyList());

                int teamMembers = members != null ? members.size() : 0;

                // Total hours for this project
                BigDecimal totalHours = projectEntries.stream()
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                // Prepare result map
                Map<String, Object> projectMap = new LinkedHashMap<>();
                projectMap.put("projectId", projectId);
                projectMap.put("projectName", projectName);
                projectMap.put("teamMembers", teamMembers);
                projectMap.put("totalHours", totalHours);

                projectBreakdown.add(projectMap);
        }

        return projectBreakdown;
        }

        public List<Map<String, Object>> buildProjectUserHoursBreakdown(
        int month,
        int year,
        Map<Long, Map<String, Object>> projectDirectory,
        Map<Long, Map<String, Object>> allUsers
) {

    // Step 1: Date range
    LocalDate firstDay = LocalDate.of(year, month, 1);
    LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

    // Step 2: Fetch NON-auto-generated timesheets for the period
    List<TimeSheet> monthSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
            .stream()
            .filter(ts -> ts.getWorkDate() != null &&
                    ts.getWorkDate().getMonthValue() == month &&
                    ts.getWorkDate().getYear() == year)
            .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated())) // exclude auto-generated
            .collect(Collectors.toList());

    // Step 3: Flatten to entries
    List<TimeSheetEntry> monthEntries = monthSheets.stream()
            .flatMap(ts -> ts.getEntries().stream())
            .collect(Collectors.toList());

    // Step 4: Identify ONLY projects that appear in timesheets
    Set<Long> usedProjectIds = monthEntries.stream()
            .map(TimeSheetEntry::getProjectId)
            .filter(Objects::nonNull)
            .collect(Collectors.toSet());

    // Step 5: Final result list
    List<Map<String, Object>> projectBreakdown = new ArrayList<>();

    for (Long projectId : usedProjectIds) {

        Map<String, Object> projectInfo = projectDirectory.get(projectId);
        if (projectInfo == null) {
            continue; // Unknown project from PMS (skip or include placeholder)
        }

        String projectName = (String) projectInfo.getOrDefault("name", "Unknown Project");

        // Get project members from PMS
        List<Map<String, Object>> members =
                (List<Map<String, Object>>) projectInfo.getOrDefault("members", Collections.emptyList());

        List<Map<String, Object>> memberBreakdown = new ArrayList<>();

        for (Map<String, Object> member : members) {

            Long memberId = ((Number) member.get("id")).longValue();

            // Resolve name from UMS
            String memberName = Optional.ofNullable(allUsers.get(memberId))
                    .map(u -> (String) u.get("name"))
                    .orElse("Unknown User");

            // Filter user‚Äôs entries for this project
            List<TimeSheetEntry> userProjectEntries = monthEntries.stream()
                    .filter(e -> Objects.equals(e.getProjectId(), projectId))
                    .filter(e -> Objects.equals(e.getTimeSheet().getUserId(), memberId))
                    .collect(Collectors.toList());

            // Compute billable and non-billable hours
            BigDecimal billableHours = userProjectEntries.stream()
                    .filter(TimeSheetEntry::isBillable)
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal nonBillableHours = userProjectEntries.stream()
                    .filter(e -> !e.isBillable())
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal totalHours = billableHours.add(nonBillableHours);

            // Build member record
            Map<String, Object> memberMap = new LinkedHashMap<>();
            memberMap.put("memberId", memberId);
            memberMap.put("memberName", memberName);
            memberMap.put("billableHours", billableHours);
            memberMap.put("nonBillableHours", nonBillableHours);
            memberMap.put("totalHours", totalHours);

            memberBreakdown.add(memberMap);
        }

        // Add project record to response
        Map<String, Object> projectMap = new LinkedHashMap<>();
        projectMap.put("projectId", projectId);
        projectMap.put("projectName", projectName);
        projectMap.put("members", memberBreakdown);

        projectBreakdown.add(projectMap);
    }

    return projectBreakdown;
}



}
