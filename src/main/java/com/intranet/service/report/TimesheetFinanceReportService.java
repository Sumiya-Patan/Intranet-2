package com.intranet.service.report;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import com.intranet.dto.lms.LeaveDTO;
import com.intranet.dto.lms.UserLeaveBreakdown;
import com.intranet.entity.TimeSheet;
import com.intranet.entity.TimeSheetEntry;
import com.intranet.repository.TimeSheetRepo;
import com.intranet.service.HolidayExcludeUsersService;
import com.intranet.util.cache.LeaveDirectoryService;
import com.intranet.util.cache.ProjectDirectoryService;
import com.intranet.util.cache.UserDirectoryService;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class TimesheetFinanceReportService {


    @Value("${weekly_hours}")
    private int weeklyHours;


    @Value("${leave.daily.hours}")
    private int leaveHours;

    private final TimeSheetRepo timeSheetRepo;
    private final HolidayExcludeUsersService holidayExcludeUsersService;
    private final UserDirectoryService userDirectoryService;
    private final ProjectDirectoryService projectDirectoryService;
    private final LeaveDirectoryService leaveDirectoryService;

    // ‚úÖ Authorization header builder
    private HttpEntity<Void> buildEntityWithAuth() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs == null) {
            return (HttpEntity<Void>) HttpEntity.EMPTY;
        }

        HttpServletRequest request = attrs.getRequest();
        String authHeader = request.getHeader("Authorization");

        HttpHeaders headers = new HttpHeaders();
        if (authHeader != null && !authHeader.isBlank()) {
            headers.set("Authorization", authHeader);
        }

        return new HttpEntity<>(headers);
    }

    public Map<String, Object> getTimesheetFinanceReport(int month, int year) {

        // Step 4Ô∏è‚É£: Get Auth Header and Fetch User Info Cache
        HttpEntity<Void> entity = buildEntityWithAuth();
        String authHeader = entity.getHeaders().getFirst("Authorization");
        Map<Long, Map<String, Object>> allUsers = userDirectoryService.fetchAllUsers(authHeader);
        Map<Long, Map<String, Object>> projectDirectory =
                projectDirectoryService.fetchAllProjects(authHeader);
        

        // ‚úÖ Step 1: Get holiday dates for users to exclude
        List<LocalDate> holidayDates = holidayExcludeUsersService.getUserHolidayDates(month);

        // ‚úÖ Step 2: Filter to only include holidays from this year
        holidayDates = holidayDates.stream()
                .filter(date -> date != null && date.getYear() == year)
                .toList();

        // ‚úÖ Step 2: Define current month range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());
        int totalDaysInMonth = firstDay.lengthOfMonth();

        // ‚úÖ Calculate working days
        int totalWorkingDays = totalDaysInMonth - holidayDates.size();
        
        // ‚úÖ Step 4: Fetch all timesheets for this month and year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay);

        // ‚úÖ Step 5: Filter strictly by same year (safety check)
        List<TimeSheet> currentYearTimeSheets = allTimeSheets.stream()
                .filter(ts -> ts.getWorkDate() != null && ts.getWorkDate().getYear() == year)
                .toList();

         // ‚úÖ Step 6: Calculate total hours (include auto-generated)
        BigDecimal totalHours = currentYearTimeSheets.stream()
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 7: Total Billable Hours (exclude auto-generated)
        BigDecimal totalBillableHours = currentYearTimeSheets.stream()
                .filter(ts -> !ts.getAutoGenerated()) // exclude system-generated
                .flatMap(ts -> ts.getEntries().stream())
                .filter(TimeSheetEntry::isBillable)
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 8: Total Non-Billable Hours (include auto-generated + non-billable entries)
        BigDecimal nonBillableFromEntries = currentYearTimeSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .filter(e -> !e.isBillable())
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal autoGeneratedHours = currentYearTimeSheets.stream()
                .filter(TimeSheet::getAutoGenerated)
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal totalNonBillableHours = nonBillableFromEntries.add(autoGeneratedHours); 

        // ‚úÖ Step 8: Calculate Utilization Rate = (Billable / Non-Billable) * 100
        BigDecimal utilizationRate = BigDecimal.ZERO;
        String utilizationRateStr = "0.00%";

        if (totalNonBillableHours.compareTo(BigDecimal.ZERO) > 0) {
            utilizationRate = totalBillableHours
                    .divide(totalHours, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100))
                    .setScale(2, RoundingMode.HALF_UP);

            utilizationRateStr = utilizationRate.toPlainString() + "%";
        }

        // 9. Hours Breakdown
        Map<String, Object> hoursBreakdown = new LinkedHashMap<>();
        hoursBreakdown.put("billableHours", totalBillableHours);
        hoursBreakdown.put("nonBillableHours", totalNonBillableHours);
        hoursBreakdown.put("leaveHours", calculateLeaveHours(month, year, authHeader));
        hoursBreakdown.put("totalHours", totalHours);
        
        // Step üîü: Build final response
        Map<String, Object> response = new LinkedHashMap<>();
        response.put("month", month);
        response.put("year", year);
        response.put("totalEmployees", allUsers.size());
        response.put("totalHolidayDates", holidayDates.size());
        response.put("totalWorkingDays", totalWorkingDays);
        response.put("holidayDates", holidayDates);
        response.put("totalHoursWorked", totalHours);
        response.put("totalBillableHours", totalBillableHours);
        response.put("totalNonBillableHours", totalNonBillableHours);
        response.put("utilizationRate", utilizationRateStr);
        response.put("hoursBreakdown", hoursBreakdown);
        response.put("employeeBreakdown", buildEmployeeBreakdown(month, year, allUsers));
        response.put("employeeProductivity", buildEmployeeProductivity(month, year, allUsers));
        response.put("projectBreakdown", buildProjectBreakdown(month, year, projectDirectory));
        response.put("projectUserHoursBreakdown",
                buildProjectUserHoursBreakdown(month, year, projectDirectory, allUsers));
        response.put("leaveHoursBreakdown",
        buildLeaveHoursBreakdown(month, year, authHeader, allUsers));

        return response;
    }
    public List<Map<String, Object>> buildEmployeeBreakdown(int month, int year, Map<Long, Map<String, Object>> allUsers) {

        // Step 1Ô∏è‚É£: Define month range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all timesheets for the given month & year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .toList();

        // Step 3Ô∏è‚É£: Get unique user IDs
        Set<Long> userIds = allTimeSheets.stream()
                .map(TimeSheet::getUserId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        // Step 5Ô∏è‚É£: Prepare employee breakdown list
        List<Map<String, Object>> employeeBreakdown = new ArrayList<>();

        for (Long userId : userIds) {

            // Filter timesheets for this user in given month & year
            List<TimeSheet> userSheets = allTimeSheets.stream()
                    .filter(ts -> ts.getUserId().equals(userId) &&
                            ts.getWorkDate().getMonthValue() == month &&
                            ts.getWorkDate().getYear() == year)
                    .toList();

            // ‚úÖ Working Days (exclude auto-generated)
            long workingDays = userSheets.stream()
                    .filter(ts -> !ts.getAutoGenerated())
                    .map(TimeSheet::getWorkDate)
                    .distinct()
                    .count();

            // ‚úÖ Billable Hours (entries where isBillable = true)
            BigDecimal billableHours = userSheets.stream()
                    .filter(ts -> !ts.getAutoGenerated())
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(TimeSheetEntry::isBillable)
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Non-Billable Hours (entries where isBillable = false + auto-generated)
            BigDecimal nonBillableFromEntries = userSheets.stream()
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(e -> !e.isBillable())
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal autoGeneratedHours = userSheets.stream()
                    .filter(TimeSheet::getAutoGenerated)
                    .map(TimeSheet::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            BigDecimal nonBillableHours = nonBillableFromEntries.add(autoGeneratedHours);

            // ‚úÖ Leave Hours (fixed 8 for now)
            BigDecimal leaveHours = BigDecimal.valueOf(8);

            // ‚úÖ Total Hours = Billable + Non-Billable
            BigDecimal totalHours = billableHours.add(nonBillableHours);

            // ‚úÖ Productivity = (Billable / Total) * 100
            BigDecimal productivity = BigDecimal.ZERO;
            if (totalHours.compareTo(BigDecimal.ZERO) > 0) {
                productivity = billableHours
                        .divide(totalHours, 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                        .setScale(2, RoundingMode.HALF_UP);
            }

            // ‚úÖ Resolve name from UMS cache
            String name = Optional.ofNullable(allUsers.get(userId))
                    .map(u -> (String) u.get("name"))
                    .orElse("Unknown User");

            // ‚úÖ Build employee summary map
            Map<String, Object> emp = new LinkedHashMap<>();
            emp.put("name", name);
            emp.put("workingDays", workingDays);
            emp.put("billableHours", billableHours);
            emp.put("nonBillableHours", nonBillableHours);
            emp.put("leaveHours", leaveHours);
            emp.put("totalHours", totalHours);
            emp.put("productivity", productivity.toPlainString() + "%");

            employeeBreakdown.add(emp);
        }

        return employeeBreakdown;
    }
        public List<Map<String, Object>> buildEmployeeProductivity(int month, int year, Map<Long, Map<String, Object>> allUsers) {

        // Step 1Ô∏è‚É£: Define date range for month
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all timesheets for month and year
        List<TimeSheet> allTimeSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .toList();

        // Step 3Ô∏è‚É£: Get distinct user IDs
        Set<Long> userIds = allTimeSheets.stream()
                .map(TimeSheet::getUserId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        // Step 5Ô∏è‚É£: Build employee productivity details
        List<Map<String, Object>> productivityList = new ArrayList<>();

        for (Long userId : userIds) {

            List<TimeSheet> userSheets = allTimeSheets.stream()
                    .filter(ts -> ts.getUserId().equals(userId))
                    .toList();

            // ‚úÖ Working Days (exclude auto-generated)
            long workingDays = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .map(TimeSheet::getWorkDate)
                    .distinct()
                    .count();

            // ‚úÖ Billable Hours (exclude auto-generated)
            BigDecimal billableHours = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(TimeSheetEntry::isBillable)
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Non-Billable Hours (exclude auto-generated)
            BigDecimal nonBillableHours = userSheets.stream()
                    .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                    .flatMap(ts -> ts.getEntries().stream())
                    .filter(e -> !e.isBillable())
                    .map(TimeSheetEntry::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Auto-Generated Hours
            BigDecimal autoGeneratedHours = userSheets.stream()
                    .filter(TimeSheet::getAutoGenerated)
                    .map(TimeSheet::getHoursWorked)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);

            // ‚úÖ Total Hours = billable + non-billable + auto-generated
            BigDecimal totalHours = billableHours.add(nonBillableHours).add(autoGeneratedHours);

            // ‚úÖ Productivity = (billable + non-billable) / 160 * 100
            BigDecimal productivity = BigDecimal.ZERO;
            if (billableHours.add(nonBillableHours).compareTo(BigDecimal.ZERO) > 0) {
                productivity = billableHours.add(nonBillableHours)
                        .divide(BigDecimal.valueOf(weeklyHours), 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                        .setScale(2, RoundingMode.HALF_UP);
            }

            // ‚úÖ Resolve employee name
            String name = Optional.ofNullable(allUsers.get(userId))
                    .map(u -> (String) u.get("name"))
                    .orElse("Unknown User");

            // ‚úÖ Build productivity record
            Map<String, Object> prod = new LinkedHashMap<>();
            prod.put("employeeId", userId);
            prod.put("employeeName", name);
            prod.put("workingDays", workingDays);
            prod.put("billableHours", billableHours);
            prod.put("nonBillableHours", nonBillableHours);
            prod.put("autoGeneratedHours", autoGeneratedHours);
            prod.put("totalHours", totalHours);
            prod.put("productivity", productivity.toPlainString() + "%");

            productivityList.add(prod);
        }

        return productivityList;
    }
        public List<Map<String, Object>> buildProjectBreakdown(
        int month,
        int year,
        Map<Long, Map<String, Object>> projectDirectory
        ) {

        // Step 1Ô∏è‚É£: Define month date range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2Ô∏è‚É£: Fetch all NON-auto-generated timesheets for this month & year
        List<TimeSheet> monthSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated())) // exclude auto-generated
                .collect(Collectors.toList());

        // Step 3Ô∏è‚É£: Collect all entries for this month
        List<TimeSheetEntry> entries = monthSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .collect(Collectors.toList());

        // Step 4Ô∏è‚É£: Group entries by project ID
        Map<Long, List<TimeSheetEntry>> projectEntryMap = entries.stream()
                .filter(e -> e.getProjectId() != null)
                .collect(Collectors.groupingBy(TimeSheetEntry::getProjectId));

        // Step 6Ô∏è‚É£: Build final result
        List<Map<String, Object>> projectBreakdown = new ArrayList<>();

        for (Map.Entry<Long, List<TimeSheetEntry>> entry : projectEntryMap.entrySet()) {

                Long projectId = entry.getKey();
                List<TimeSheetEntry> projectEntries = entry.getValue();

                // Project metadata from PMS
                Map<String, Object> projectInfo = projectDirectory.get(projectId);
                if (projectInfo == null) continue;

                String projectName = (String) projectInfo.getOrDefault("name", "Unknown Project");

                List<Map<String, Object>> members =
                        (List<Map<String, Object>>) projectInfo.getOrDefault("members", Collections.emptyList());

                int teamMembers = members != null ? members.size() : 0;

                // Total hours
                BigDecimal totalHours = projectEntries.stream()
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                // Billable hours for this project
                BigDecimal billableHours = projectEntries.stream()
                        .filter(TimeSheetEntry::isBillable)
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                // Non-billable hours for this project
                BigDecimal nonBillableHours = projectEntries.stream()
                        .filter(e -> !e.isBillable())
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                // Build project response
                Map<String, Object> projectMap = new LinkedHashMap<>();
                projectMap.put("projectId", projectId);
                projectMap.put("projectName", projectName);
                projectMap.put("teamMembers", teamMembers);
                projectMap.put("totalHours", totalHours);
                projectMap.put("billableHours", billableHours);
                projectMap.put("nonBillableHours", nonBillableHours);

                projectBreakdown.add(projectMap);
        }

        return projectBreakdown;
        }


        public List<Map<String, Object>> buildProjectUserHoursBreakdown(
        int month,
        int year,
        Map<Long, Map<String, Object>> projectDirectory,
        Map<Long, Map<String, Object>> allUsers
        ) {

        // Step 1: Date range
        LocalDate firstDay = LocalDate.of(year, month, 1);
        LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

        // Step 2: Fetch NON-auto-generated timesheets
        List<TimeSheet> monthSheets = timeSheetRepo.findByWorkDateBetween(firstDay, lastDay)
                .stream()
                .filter(ts -> ts.getWorkDate() != null &&
                        ts.getWorkDate().getMonthValue() == month &&
                        ts.getWorkDate().getYear() == year)
                .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
                .collect(Collectors.toList());

        // Step 3: Flatten entries
        List<TimeSheetEntry> monthEntries = monthSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .collect(Collectors.toList());

        // Step 4: Only consider projects that appear in timesheets
        Set<Long> usedProjectIds = monthEntries.stream()
                .map(TimeSheetEntry::getProjectId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());

        List<Map<String, Object>> projectBreakdown = new ArrayList<>();

        for (Long projectId : usedProjectIds) {

                Map<String, Object> projectInfo = projectDirectory.get(projectId);
                if (projectInfo == null) continue;

                String projectName = (String) projectInfo.getOrDefault("name", "Unknown Project");

                // ‚û§ Owner Information
                Long ownerId = projectInfo.get("ownerId") != null
                        ? ((Number) projectInfo.get("ownerId")).longValue()
                        : null;

                String ownerName = ownerId != null && allUsers.containsKey(ownerId)
                        ? (String) allUsers.get(ownerId).get("name")
                        : "Unknown Owner";

                // ‚û§ Members from PMS
                List<Map<String, Object>> members =
                        (List<Map<String, Object>>) projectInfo.getOrDefault("members", Collections.emptyList());

                List<Map<String, Object>> memberBreakdown = new ArrayList<>();

                // Track total project hours
                BigDecimal totalProjectHours = BigDecimal.ZERO;

                // First pass ‚Üí calculate hours per member
                List<Map<String, Object>> rawMemberHours = new ArrayList<>();

                for (Map<String, Object> member : members) {

                Long memberId = ((Number) member.get("id")).longValue();

                String memberName = Optional.ofNullable(allUsers.get(memberId))
                        .map(u -> (String) u.get("name"))
                        .orElse("Unknown User");

                // Entries for this member for this project
                List<TimeSheetEntry> userProjectEntries = monthEntries.stream()
                        .filter(e -> Objects.equals(e.getProjectId(), projectId))
                        .filter(e -> Objects.equals(e.getTimeSheet().getUserId(), memberId))
                        .collect(Collectors.toList());

                BigDecimal billableHours = userProjectEntries.stream()
                        .filter(TimeSheetEntry::isBillable)
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                BigDecimal nonBillableHours = userProjectEntries.stream()
                        .filter(e -> !e.isBillable())
                        .map(TimeSheetEntry::getHoursWorked)
                        .filter(Objects::nonNull)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);

                BigDecimal totalHours = billableHours.add(nonBillableHours);

                // Track for later contribution calculation
                Map<String, Object> raw = new HashMap<>();
                raw.put("memberId", memberId);
                raw.put("memberName", memberName);
                raw.put("billableHours", billableHours);
                raw.put("nonBillableHours", nonBillableHours);
                raw.put("totalHours", totalHours);

                rawMemberHours.add(raw);

                totalProjectHours = totalProjectHours.add(totalHours);
                }

                // Second pass ‚Üí add contribution %
                for (Map<String, Object> raw : rawMemberHours) {

                BigDecimal memberTotal = (BigDecimal) raw.get("totalHours");

                BigDecimal contribution = BigDecimal.ZERO;

                if (totalProjectHours.compareTo(BigDecimal.ZERO) > 0) {
                        contribution = memberTotal
                                .divide(totalProjectHours, 4, RoundingMode.HALF_UP)
                                .multiply(BigDecimal.valueOf(100))
                                .setScale(2, RoundingMode.HALF_UP);
                }

                Map<String, Object> memberMap = new LinkedHashMap<>();
                memberMap.put("memberId", raw.get("memberId"));
                memberMap.put("memberName", raw.get("memberName"));
                memberMap.put("billableHours", raw.get("billableHours"));
                memberMap.put("nonBillableHours", raw.get("nonBillableHours"));
                memberMap.put("totalHours", raw.get("totalHours"));
                memberMap.put("contribution", contribution.toPlainString() + "%");

                memberBreakdown.add(memberMap);
                }

                // Build Project Record
                Map<String, Object> projectMap = new LinkedHashMap<>();
                projectMap.put("projectId", projectId);
                projectMap.put("projectName", projectName);
                projectMap.put("ownerId", ownerId);
                projectMap.put("ownerName", ownerName);
                projectMap.put("totalProjectHours", totalProjectHours);
                projectMap.put("members", memberBreakdown);

                projectBreakdown.add(projectMap);
        }

        return projectBreakdown;
        }


    private BigDecimal calculateLeaveHours(int month, int year, String authHeader) {

    // Fetch all leaves for the month using the directory cache
    List<LeaveDTO> leaves = leaveDirectoryService.fetchLeaves(year, month, authHeader);

    BigDecimal totalLeaveHours = BigDecimal.ZERO;

    LocalDate monthStart = LocalDate.of(year, month, 1);
    LocalDate monthEnd = monthStart.withDayOfMonth(monthStart.lengthOfMonth());

    for (LeaveDTO leave : leaves) {

        // ‚úî Skip non-approved leaves
        if (!"APPROVED".equalsIgnoreCase(leave.getStatus())) {
            continue;
        }

        // Adjust range to fit inside this month
        LocalDate start = leave.getStartDate();
        LocalDate end = leave.getEndDate();

        // ‚úî Trim dates outside this month window
        LocalDate effectiveStart = start.isBefore(monthStart) ? monthStart : start;
        LocalDate effectiveEnd = end.isAfter(monthEnd) ? monthEnd : end;

        // Loop through all dates
        LocalDate date = effectiveStart;
        while (!date.isAfter(effectiveEnd)) {

            // ‚úî Only count Monday‚ÄìFriday
            switch (date.getDayOfWeek()) {
                case SATURDAY:
                case SUNDAY:
                    break;   // skip weekends

                default:
                    // ‚úî Each valid day counts as 8 hours
                    totalLeaveHours = totalLeaveHours.add(BigDecimal.valueOf(leaveHours));
            }

            date = date.plusDays(1);
        }
    }

    return totalLeaveHours;
        }

        public UserLeaveBreakdown calculateLeaveDetailsForUser(
                Long userId, int month, int year, String authHeader) {

        // Fetch all leaves for the month using LMS cache
        List<LeaveDTO> leaves = leaveDirectoryService.fetchLeaves(year, month, authHeader);

        BigDecimal totalLeaveHours = BigDecimal.ZERO;
        int totalLeaveDays = 0;
        List<LocalDate> leaveDates = new ArrayList<>();

        LocalDate monthStart = LocalDate.of(year, month, 1);
        LocalDate monthEnd = monthStart.withDayOfMonth(monthStart.lengthOfMonth());

        for (LeaveDTO leave : leaves) {

                // Skip different user
                if (!leave.getEmployeeId().equals(userId)) {
                continue;
                }

                // Skip non-approved leaves
                if (!"APPROVED".equalsIgnoreCase(leave.getStatus())) {
                continue;
                }

                LocalDate start = leave.getStartDate();
                LocalDate end = leave.getEndDate();

                // Clamp to month
                LocalDate effectiveStart = start.isBefore(monthStart) ? monthStart : start;
                LocalDate effectiveEnd = end.isAfter(monthEnd) ? monthEnd : end;

                // Iterate dates
                LocalDate date = effectiveStart;
                while (!date.isAfter(effectiveEnd)) {

                switch (date.getDayOfWeek()) {
                        case SATURDAY:
                        case SUNDAY:
                        break; // skip weekends

                        default:
                        totalLeaveHours = totalLeaveHours.add(BigDecimal.valueOf(leaveHours));
                        totalLeaveDays++;
                        leaveDates.add(date);
                }

                date = date.plusDays(1);
                }
        }

        // Build response object
        UserLeaveBreakdown breakdown = new UserLeaveBreakdown();
        breakdown.totalHours = totalLeaveHours;
        breakdown.totalDays = totalLeaveDays;
        breakdown.leaveDates = leaveDates;

        return breakdown;
        }

        private List<Map<String, Object>> buildLeaveHoursBreakdown(
        int month,
        int year,
        String authHeader,
        Map<Long, Map<String, Object>> allUsers
) {

    List<LeaveDTO> leaves = leaveDirectoryService.fetchLeaves(year, month, authHeader);

    LocalDate monthStart = LocalDate.of(year, month, 1);
    LocalDate monthEnd = monthStart.withDayOfMonth(monthStart.lengthOfMonth());

    // Store per-user stats
    Map<Long, Integer> userDaysMap = new HashMap<>();
    Map<Long, BigDecimal> userHoursMap = new HashMap<>();

    for (LeaveDTO leave : leaves) {

        // Only approved leaves
        if (!"APPROVED".equalsIgnoreCase(leave.getStatus())) {
            continue;
        }

        Long userId = leave.getEmployeeId();

        LocalDate start = leave.getStartDate();
        LocalDate end = leave.getEndDate();

        // Trim range to the month
        LocalDate effectiveStart = start.isBefore(monthStart) ? monthStart : start;
        LocalDate effectiveEnd = end.isAfter(monthEnd) ? monthEnd : end;

        // Count weekdays
        int days = 0;

        LocalDate date = effectiveStart;
        while (!date.isAfter(effectiveEnd)) {

            switch (date.getDayOfWeek()) {
                case SATURDAY:
                case SUNDAY:
                    break; // skip weekends
                default:
                    days++;
            }

            date = date.plusDays(1);
        }

        if (days > 0) {
            userDaysMap.put(userId, userDaysMap.getOrDefault(userId, 0) + days);

            BigDecimal hours = BigDecimal.valueOf(days * leaveHours);
            userHoursMap.put(
                    userId,
                    userHoursMap.getOrDefault(userId, BigDecimal.ZERO).add(hours)
            );
        }
    }

    // Total leave hours for month ‚Äî needed for contribution
    BigDecimal totalLeaveHours = userHoursMap.values().stream()
            .reduce(BigDecimal.ZERO, BigDecimal::add);

    // Build final breakdown list
    List<Map<String, Object>> breakdown = new ArrayList<>();

    for (Long userId : userDaysMap.keySet()) {

        int noOfDays = userDaysMap.get(userId);
        BigDecimal leaveHours = userHoursMap.get(userId);

        BigDecimal contribution = BigDecimal.ZERO;

        if (totalLeaveHours.compareTo(BigDecimal.ZERO) > 0) {
            contribution = leaveHours
                    .divide(totalLeaveHours, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100))
                    .setScale(2, RoundingMode.HALF_UP);
        }

        String userName = Optional.ofNullable(allUsers.get(userId))
                .map(u -> (String) u.get("name"))
                .orElse("Unknown User");

        Map<String, Object> entry = new LinkedHashMap<>();
        entry.put("userId", userId);
        entry.put("userName", userName);
        entry.put("noOfDays", noOfDays);
        entry.put("leaveHours", leaveHours);
        entry.put("contribution", contribution.toPlainString() + "%");

        breakdown.add(entry);
    }

    return breakdown;
        }

        public Map<String, Object> buildProjectBreakdownForUser(
        Long userId,
        int month,
        int year,
        Map<Long, Map<String, Object>> projectDirectory
        ) {

    Map<String, Object> finalResponse = new LinkedHashMap<>();

    // Step 1: Define month range
    LocalDate firstDay = LocalDate.of(year, month, 1);
    LocalDate lastDay = firstDay.withDayOfMonth(firstDay.lengthOfMonth());

    // Step 2: Fetch NON-auto-generated timesheets for THIS user only
    List<TimeSheet> userSheets = timeSheetRepo.findByUserIdAndWorkDateBetween(userId, firstDay, lastDay)
            .stream()
            .filter(ts -> ts.getWorkDate() != null &&
                    ts.getWorkDate().getMonthValue() == month &&
                    ts.getWorkDate().getYear() == year)
            .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated()))
            .collect(Collectors.toList());

    // Step 3: Collect all entries of this user
    List<TimeSheetEntry> userEntries = userSheets.stream()
            .flatMap(ts -> ts.getEntries().stream())
            .filter(e -> e.getHoursWorked() != null)
            .collect(Collectors.toList());

    // Step 4: Group entries by project
    Map<Long, List<TimeSheetEntry>> userProjectMap = userEntries.stream()
            .filter(e -> e.getProjectId() != null)
            .collect(Collectors.groupingBy(TimeSheetEntry::getProjectId));

    List<Map<String, Object>> projectBreakdown = new ArrayList<>();

    BigDecimal totalBillableAll = BigDecimal.ZERO;
    BigDecimal totalNonBillableAll = BigDecimal.ZERO;

    // Step 5: Build each project summary
    for (Map.Entry<Long, List<TimeSheetEntry>> entry : userProjectMap.entrySet()) {

        Long projectId = entry.getKey();
        List<TimeSheetEntry> projectEntries = entry.getValue();

        Map<String, Object> projectInfo = projectDirectory.get(projectId);
        if (projectInfo == null) continue;

        String projectName = (String) projectInfo.getOrDefault("name", "Unknown Project");

        BigDecimal billableHours = projectEntries.stream()
                .filter(TimeSheetEntry::isBillable)
                .map(TimeSheetEntry::getHoursWorked)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal nonBillableHours = projectEntries.stream()
                .filter(e -> !e.isBillable())
                .map(TimeSheetEntry::getHoursWorked)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal totalHours = billableHours.add(nonBillableHours);

        // Collect global totals
        totalBillableAll = totalBillableAll.add(billableHours);
        totalNonBillableAll = totalNonBillableAll.add(nonBillableHours);

        Map<String, Object> projectMap = new LinkedHashMap<>();
        projectMap.put("projectId", projectId);
        projectMap.put("projectName", projectName);
        projectMap.put("totalHours", totalHours);
        projectMap.put("billableHours", billableHours);
        projectMap.put("nonBillableHours", nonBillableHours);

        projectBreakdown.add(projectMap);
    }

    // Compute global totals
    BigDecimal globalTotalHours = totalBillableAll.add(totalNonBillableAll);

    // Step 6: Compute contribution for each project
    for (Map<String, Object> project : projectBreakdown) {
        BigDecimal total = (BigDecimal) project.get("totalHours");

        BigDecimal contribution = BigDecimal.ZERO;

        if (globalTotalHours.compareTo(BigDecimal.ZERO) > 0 &&
                total.compareTo(BigDecimal.ZERO) > 0) {

            contribution = total
                    .divide(globalTotalHours, 4, RoundingMode.HALF_UP)
                    .multiply(BigDecimal.valueOf(100))
                    .setScale(2, RoundingMode.HALF_UP);
        }

        project.put("contribution", contribution);
    }

    // Step 7: Build Final Response
    finalResponse.put("totalBillableHours", totalBillableAll);
    finalResponse.put("totalNonBillableHours", totalNonBillableAll);
    finalResponse.put("globalTotalHours", globalTotalHours);
    finalResponse.put("projects", projectBreakdown);

    return finalResponse;
        }


}
