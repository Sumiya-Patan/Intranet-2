package com.intranet.service.RMS;

import com.intranet.dto.rms.MonthlySummaryDTO;
import com.intranet.dto.rms.UserMonthlyUtilizationDTO;
import com.intranet.entity.TimeSheet;
import com.intranet.entity.TimeSheetEntry;
import com.intranet.repository.TimeSheetRepo;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.YearMonth;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class UtilizationService {

    private final TimeSheetRepo timeSheetRepo;

    public UserMonthlyUtilizationDTO getMonthlyUtilization(Long userId, int year, int month) {

    if (month < 1 || month > 12) {
        throw new IllegalArgumentException("Month must be between 1 and 12");
    }

    LocalDate selectedDate = LocalDate.of(year, month, 1);

    // ‚ùå Prevent future months
    LocalDate currentMonth = LocalDate.now().withDayOfMonth(1);
    if (selectedDate.isAfter(currentMonth)) {
        throw new IllegalArgumentException("Future month/year not allowed");
    }

    // 6-month window
    LocalDate startDate = selectedDate.minusMonths(5).withDayOfMonth(1);
    LocalDate endDate = selectedDate.withDayOfMonth(selectedDate.lengthOfMonth());

    // Fetch all timesheets in 6-month window
    List<TimeSheet> timeSheets =
            timeSheetRepo.findByUserIdAndWorkDateBetween(userId, startDate, endDate);

    // Group timesheets by YearMonth
    Map<YearMonth, List<TimeSheet>> grouped =
            timeSheets.stream()
                    .collect(Collectors.groupingBy(
                            ts -> YearMonth.from(ts.getWorkDate())
                    ));

    Map<String, MonthlySummaryDTO> monthlySummary = new LinkedHashMap<>();

    // Loop through last 6 months in correct order
    for (int i = 5; i >= 0; i--) {

        LocalDate monthDate = selectedDate.minusMonths(i);
        YearMonth ym = YearMonth.from(monthDate);

        List<TimeSheet> monthSheets = grouped.getOrDefault(ym, new ArrayList<>());

        BigDecimal billable = BigDecimal.ZERO;
        BigDecimal nonBillable = BigDecimal.ZERO;

        for (TimeSheet ts : monthSheets) {

            if (Boolean.TRUE.equals(ts.getAutoGenerated())) {
                nonBillable = nonBillable.add(
                        ts.getHoursWorked() != null ? ts.getHoursWorked() : BigDecimal.ZERO
                );
                continue;
            }

            for (TimeSheetEntry entry : ts.getEntries()) {

                BigDecimal hours = entry.getHoursWorked() != null
                        ? entry.getHoursWorked()
                        : BigDecimal.ZERO;

                if (entry.isBillable()) {
                    billable = billable.add(hours);
                } else {
                    nonBillable = nonBillable.add(hours);
                }
            }
        }

        BigDecimal total = billable.add(nonBillable);

        double billableUtil = 0.0;
        double nonBillableUtil = 0.0;

        if (total.compareTo(BigDecimal.ZERO) > 0) {
            billableUtil = billable
                    .multiply(BigDecimal.valueOf(100))
                    .divide(total, 2, RoundingMode.HALF_UP)
                    .doubleValue();

            nonBillableUtil = nonBillable
                    .multiply(BigDecimal.valueOf(100))
                    .divide(total, 2, RoundingMode.HALF_UP)
                    .doubleValue();
        }

        monthlySummary.put(
                monthDate.getMonth().name(),
                MonthlySummaryDTO.builder()
                        .billableUtilization(billableUtil)
                        .nonBillableUtilization(nonBillableUtil)
                        .build()
        );
    }

    return UserMonthlyUtilizationDTO.builder()
            .userId(userId)
            .monthlySummary(monthlySummary)
            .build();
    }
}
