package com.intranet.service.external;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.intranet.dto.TimeSheetEntrySummaryDTO;
import com.intranet.dto.TimeSheetSummaryDTO;
import com.intranet.dto.WeekSummaryDTO;
import com.intranet.dto.external.ManagerWeeklySummaryDTO;
import com.intranet.entity.TimeSheet;
import com.intranet.entity.TimeSheetEntry;
import com.intranet.entity.TimeSheetOnHolidays;
import com.intranet.entity.WeekInfo;
import com.intranet.repository.TimeSheetOnHolidaysRepo;
import com.intranet.repository.TimeSheetRepo;
import com.intranet.service.TimeUtil;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ManagerWeeklySummaryService {

        private final RestTemplate restTemplate;
        private final TimeSheetRepo timeSheetRepository;
        private final TimeSheetOnHolidaysRepo timeSheetOnHolidaysRepo;

    @Value("${pms.api.base-url}")
    private String pmsBaseUrl;

    @Value("${ums.api.base-url}")
    private String umsBaseUrl;

    public List<ManagerWeeklySummaryDTO> getWeeklySubmittedTimesheetsByManager(Long managerId, String authHeader,LocalDate startOfMonth,LocalDate endOfMonth) {
    HttpHeaders headers = new HttpHeaders();
    headers.set("Authorization", authHeader);
    HttpEntity<Void> entity = new HttpEntity<>(headers);

//     // Step 1: Get all projects owned by this manager
    String url = String.format("%s/projects/owner", pmsBaseUrl);
    ResponseEntity<List<Map<String, Object>>> response = restTemplate.exchange(
            url, HttpMethod.GET, entity, new ParameterizedTypeReference<>() {});
    List<Map<String, Object>> projects = response.getBody();
    if (projects == null || projects.isEmpty()) return Collections.emptyList();

    // Step 2: Get all member IDs under these projects
    Set<Long> memberIds = projects.stream()
            .flatMap(p -> ((List<Map<String, Object>>) p.get("members")).stream())
            .map(m -> ((Number) m.get("id")).longValue())
            .collect(Collectors.toSet());
    if (memberIds.isEmpty()) return Collections.emptyList();

    // Step 3: Fetch all non-draft timesheets of these members
    List<TimeSheet> allSheets = timeSheetRepository.findNonDraftByUserIds(memberIds);
    if (allSheets.isEmpty()) return Collections.emptyList();
    
    // âœ… Step 3.1: Filter timesheets within the current month
    List<TimeSheet> filteredSheets = allSheets.stream()
            .filter(ts -> !ts.getWorkDate().isBefore(startOfMonth) && !ts.getWorkDate().isAfter(endOfMonth))
            .collect(Collectors.toList());
    if (filteredSheets.isEmpty()) return Collections.emptyList();

    // Step 4: Filter timesheets where manager has at least one project entry
    List<TimeSheet> managerSheets = filteredSheets.stream()
        .filter(ts -> {

            // A) Include empty timesheets
            if (ts.getEntries().isEmpty()) return true;

            // B) Include auto-generated timesheets
            if (Boolean.TRUE.equals(ts.getAutoGenerated())) return true;

            // C) Include holiday mapped timesheets
            boolean isHoliday = timeSheetOnHolidaysRepo.findByTimeSheetId(ts.getId())
                    .map(TimeSheetOnHolidays::getIsHoliday)
                    .orElse(false);
            if (isHoliday) return true;

            // D) Normal project-based match
            return ts.getEntries().stream().anyMatch(e ->
                    projects.stream().anyMatch(p ->
                            ((Number) p.get("id")).longValue() == e.getProjectId())
            );
        })
        .toList();


    if (managerSheets.isEmpty()) return Collections.emptyList();

        // Step 5: Fetch all users in one call from UMS and cache them
        Map<Long, Map<String, Object>> userCache = new HashMap<>();
        try {
        String allUsersUrl = String.format("%s/admin/users?page=1&limit=500", umsBaseUrl);
        ResponseEntity<Map<String, Object>> userResponse =
                restTemplate.exchange(allUsersUrl, HttpMethod.GET, entity, new ParameterizedTypeReference<>() {});
        
        Map<String, Object> responseBody = userResponse.getBody();
        if (responseBody != null && responseBody.containsKey("users")) {
                List<Map<String, Object>> users = (List<Map<String, Object>>) responseBody.get("users");
                for (Map<String, Object> user : users) {
                Long id = ((Number) user.get("user_id")).longValue();
                userCache.put(id, user);
                }
        }
        } catch (Exception e) {
        e.printStackTrace(); // optionally log with logger.warn("Failed to load users", e)
        }
        Map<Long, String> userNameCache = new HashMap<>();
        Map<Long, String> userEmailCache = new HashMap<>();

        for (Long uid : memberIds) {
        Map<String, Object> user = userCache.get(uid);
        if (user != null) {
                String firstName = (String) user.getOrDefault("first_name", "");
                String lastName = (String) user.getOrDefault("last_name", "");
                String fullName = (firstName + " " + lastName).trim();
                String email = (String) user.getOrDefault("mail", "unknown@example.com");

                userNameCache.put(uid, fullName.isEmpty() ? "Unknown User" : fullName);
                userEmailCache.put(uid, email);
        } else {
                userNameCache.put(uid, "Unknown User");
                userEmailCache.put(uid, "unknown@example.com");
        }
}



    // Step 6: Group by userId and build weekly summary
    return managerSheets.stream()
            .collect(Collectors.groupingBy(TimeSheet::getUserId))
            .entrySet().stream()
            .map(entry -> {
                Long userId = entry.getKey();
                List<TimeSheet> userSheets = entry.getValue();

                // âœ… Step 7: Total Billable Hours (exclude auto-generated)
        BigDecimal totalBillableHours = userSheets.stream()
                .filter(ts -> !ts.getAutoGenerated()) // exclude system-generated
                .flatMap(ts -> ts.getEntries().stream())
                .filter(TimeSheetEntry::isBillable)
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
 
        // âœ… Step 8: Total Non-Billable Hours (include auto-generated + non-billable entries)
        BigDecimal nonBillableFromEntries = userSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .filter(e -> !e.isBillable())
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
       
        BigDecimal autoGeneratedHours = userSheets.stream()
                .filter(TimeSheet::getAutoGenerated)
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
                
        BigDecimal totalHoursBN= totalBillableHours.add(nonBillableFromEntries); 

                List<WeekSummaryDTO> weekSummaries = userSheets.stream()
                        .collect(Collectors.groupingBy(ts -> ts.getWeekInfo().getWeekNo()))
                        .entrySet().stream()
                        .map(weekEntry -> {
                            Integer weekNo = weekEntry.getKey();
                            List<TimeSheet> weekSheets = weekEntry.getValue();
                            WeekInfo week = weekSheets.get(0).getWeekInfo();

                            // ðŸš¨ NEW RULE: WEEK MUST HAVE AT LEAST ONE REAL ENTRY
                                boolean weekHasRealEntries = weekSheets.stream()
                                        .anyMatch(ts ->
                                                ts.getEntries() != null &&
                                                !ts.getEntries().isEmpty() &&
                                                !Boolean.TRUE.equals(ts.getAutoGenerated())
                                        );

                                if (!weekHasRealEntries) {
                                        return null; // hide week
                                }

                            // Map to DTO with manager-specific status
                            List<TimeSheetSummaryDTO> timeSheetDTOs = weekSheets.stream()
                                    .map(ts -> mapToSummaryDTOForManager(ts, managerId, projects))
                                    .toList();

                            BigDecimal totalHours = TimeUtil.sumHours(
                                    timeSheetDTOs.stream().map(TimeSheetSummaryDTO::getHoursWorked).toList()
                            );

                            // Determine week status based on all timesheet statuses
                        Set<String> statuses = timeSheetDTOs.stream()
                                .map(TimeSheetSummaryDTO::getStatus)
                                .collect(Collectors.toSet());

                        String weekStatus;
                        if (statuses.contains("REJECTED")) {
                        weekStatus = "REJECTED";
                        } else if (statuses.size() == 1 && statuses.contains("APPROVED")) {
                        weekStatus = "APPROVED";
                        } else if (statuses.size() == 1 && statuses.contains("SUBMITTED")) {
                        weekStatus = "SUBMITTED";
                        } else if (statuses.contains("APPROVED") || statuses.contains("SUBMITTED")) {
                        weekStatus = "SUBMITTED";
                        } else {
                        weekStatus = "SUBMITTED"; // default fallback
                        }

                        WeekSummaryDTO weekDTO = new WeekSummaryDTO();
                        weekDTO.setWeekId(weekNo.longValue());
                        weekDTO.setStartDate(week.getStartDate());
                        weekDTO.setEndDate(week.getEndDate());
                        weekDTO.setTotalHours(totalHours);
                        weekDTO.setTimesheets(timeSheetDTOs);
                        weekDTO.setWeeklyStatus(weekStatus); // âœ… add this new field
                        return weekDTO;

                        })
                          .filter(dto -> dto != null)  // ðŸš¨ REMOVE NULL WEEKS
        .sorted(Comparator.comparing(WeekSummaryDTO::getWeekId).reversed())
        .collect(Collectors.toList());
                
                ManagerWeeklySummaryDTO managerDTO = new ManagerWeeklySummaryDTO();
                managerDTO.setUserId(userId);
                Map<String, Object> user = userCache.get(userId);
                String fullName = "Unknown";
                if (user != null) {
                String firstName = (String) user.getOrDefault("first_name", "");
                String lastName = (String) user.getOrDefault("last_name", "");
                fullName = (firstName + " " + lastName).trim();
                }
                managerDTO.setUserName(fullName);
                managerDTO.setBillableHours(totalBillableHours);
                managerDTO.setNonBillableHours(nonBillableFromEntries);
                managerDTO.setTotalHours(totalHoursBN);
                managerDTO.setAutogeneratedHours(autoGeneratedHours);

                managerDTO.setWeeklySummary(weekSummaries);
                return managerDTO;
            })
            // ðŸš¨ NEW RULE: Remove users who have NO valid weeks
        .filter(dto -> dto.getWeeklySummary() != null && !dto.getWeeklySummary().isEmpty())
        .toList();
 }

/**
 * Map timesheet to DTO for a specific manager.
 * Only timesheets where the manager has at least one entry will be passed here.
 * All entries are shown.
 * Status is manager-specific.
 */
private TimeSheetSummaryDTO mapToSummaryDTOForManager(TimeSheet ts, Long managerId, List<Map<String, Object>> managerProjects) {
    List<TimeSheetEntrySummaryDTO> entries = ts.getEntries().stream().map(e -> {
        TimeSheetEntrySummaryDTO dto = new TimeSheetEntrySummaryDTO();
        dto.setTimesheetEntryid(e.getId());
        dto.setProjectId(e.getProjectId());
        dto.setTaskId(e.getTaskId());
        dto.setDescription(e.getDescription());
        dto.setWorkLocation(e.getWorkLocation());
        dto.setFromTime(e.getFromTime() != null ? e.getFromTime() : null);
        dto.setToTime(e.getToTime() != null ? e.getToTime(): null);
        dto.setHoursWorked(e.getHoursWorked());
        dto.setOtherDescription(e.getOtherDescription());
        dto.setIsBillable(e.isBillable());
        return dto;
    }).toList();

    TimeSheetSummaryDTO dto = new TimeSheetSummaryDTO();
    dto.setTimesheetId(ts.getId());
    dto.setWorkDate(ts.getWorkDate());
    dto.setHoursWorked(ts.getHoursWorked());
    dto.setEntries(entries);
    // âœ… Check if the timesheet is marked as a holiday timesheet
    boolean isHolidayTimesheet = timeSheetOnHolidaysRepo.findByTimeSheetId(ts.getId())
            .map(TimeSheetOnHolidays::getIsHoliday)
            .orElse(false);
    dto.setIsHolidayTimesheet(isHolidayTimesheet);
    dto.setDefaultHolidayTimesheet(ts.getAutoGenerated());

    // Manager-specific status
    String managerStatus = ts.getReviews().stream()
            .filter(r -> r.getManagerId().equals(managerId))
            .map(r -> r.getStatus().name())
            .findFirst()
            .orElse("SUBMITTED");
    dto.setStatus(managerStatus);

    return dto;
}

}
