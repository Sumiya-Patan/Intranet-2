package com.intranet.service;

import com.intranet.dto.LeavesAndHolidaysDTO;
import com.intranet.dto.MonthlyUserReportDTO;
import com.intranet.dto.WeekSummaryDTO;
import com.intranet.dto.WeeklySummaryDTO;
import com.intranet.dto.lms.UserLeaveBreakdown;
import com.intranet.entity.TimeSheet;
import com.intranet.entity.TimeSheetEntry;
import com.intranet.repository.TimeSheetRepo;
import com.intranet.service.report.TimesheetFinanceReportService;
import com.intranet.util.cache.ProjectDirectoryService;
import com.intranet.util.cache.UserDirectoryService;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class MonthlyUserReportService {

    private final TimeSheetRepo timeSheetRepo;
    private final HolidayExcludeUsersService holidayService;

    private final UserDirectoryService userDirectoryService;
    private final ProjectDirectoryService projectDirectoryService;

    private final TimesheetFinanceReportService timesheetFinanceReportService;
    
    private final WeeklySummaryService weeklySummaryService;
    // private final UserRepository userRepository; // optional for employee name

        // ✅ Authorization header builder
    private HttpEntity<Void> buildEntityWithAuth() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attrs == null) {
            return (HttpEntity<Void>) HttpEntity.EMPTY;
        }

        HttpServletRequest request = attrs.getRequest();
        String authHeader = request.getHeader("Authorization");

        HttpHeaders headers = new HttpHeaders();
        if (authHeader != null && !authHeader.isBlank()) {
            headers.set("Authorization", authHeader);
        }

        return new HttpEntity<>(headers);
    }

    public MonthlyUserReportDTO getMonthlyUserReport(Long userId, int month, int year) {

        HttpEntity<Void> entity=buildEntityWithAuth();
        String authHeader = entity.getHeaders().getFirst("Authorization");

        Map<Long,Map<String,Object>> allUsers = userDirectoryService.fetchAllUsers(authHeader);

        Map<Long,Map<String,Object>> projectDirectory = projectDirectoryService.fetchAllProjects(authHeader);

        LocalDate startOfMonth = LocalDate.of(year, month, 1);
        LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

        // 1️⃣ Fetch timesheets for the month
        List<TimeSheet> timeSheets = timeSheetRepo
                .findByUserIdAndWorkDateBetween(userId, startOfMonth, endOfMonth);

        // 2️⃣ Flatten all entries
        List<TimeSheetEntry> allEntries = timeSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .collect(Collectors.toList());

        // 5. Day-wise summary: group by timesheet.workDate day-of-week, then reorder Mon->Sun
    Map<String, Double> tempSummary = allEntries.stream()
            .filter(e -> e.getTimeSheet() != null && e.getTimeSheet().getWorkDate() != null)
            .collect(Collectors.groupingBy(
                    e -> e.getTimeSheet().getWorkDate().getDayOfWeek().name().toLowerCase(),

                    Collectors.summingDouble(e -> e.getHoursWorked() != null ? e.getHoursWorked().doubleValue() : 0.0)
            ));
          timeSheets.stream()
        .filter(ts -> Boolean.TRUE.equals(ts.getAutoGenerated()))
        .forEach(ts -> {
            String day = ts.getWorkDate().getDayOfWeek().name().toLowerCase();
            double hours = ts.getHoursWorked() != null ? ts.getHoursWorked().doubleValue() : 0.0;
            tempSummary.put(day, tempSummary.getOrDefault(day, 0.0) + hours);
        });  

        // Define correct order and build LinkedHashMap in that order
        List<String> orderedDays = Arrays.asList(
                "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
        );

        Map<String, Double> dayWiseSummary = new LinkedHashMap<>();
        for (String day : orderedDays) {
                dayWiseSummary.put(day, tempSummary.getOrDefault(day, 0.0));
        }


         // ✅ Step 7: Total Billable Hours (exclude auto-generated)
        BigDecimal totalBillableHours = timeSheets.stream()
                .filter(ts -> !ts.getAutoGenerated()) // exclude system-generated
                .flatMap(ts -> ts.getEntries().stream())
                .filter(TimeSheetEntry::isBillable)
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
 
        // ✅ Step 8: Total Non-Billable Hours (include auto-generated + non-billable entries)
        BigDecimal nonBillableFromEntries = timeSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .filter(e -> !e.isBillable())
                .map(TimeSheetEntry::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
       
        BigDecimal autoGeneratedHours = timeSheets.stream()
                .filter(TimeSheet::getAutoGenerated)
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
 
        BigDecimal totalNonBillableHours = nonBillableFromEntries.add(autoGeneratedHours);

        // 6️⃣ Unique active project count
        int activeProjectsCount = allEntries.stream()
                .map(TimeSheetEntry::getProjectId)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet())
                .size();

        List<LocalDate> HolidayDates = holidayService.getUserHolidaysMonthYear(userId, month, year);
        int totalHolidays = HolidayDates.size();


        UserLeaveBreakdown totalLeavesData = timesheetFinanceReportService.calculateLeaveDetailsForUser(userId, month, year,authHeader);
        
        
        LeavesAndHolidaysDTO leavesAndHolidays = new LeavesAndHolidaysDTO();
        leavesAndHolidays.setTotalHolidays(totalHolidays);
        leavesAndHolidays.setHolidayDates(HolidayDates);
        leavesAndHolidays.setLeaveDates(totalLeavesData.getLeaveDates());
        leavesAndHolidays.setTotalLeavesHours(totalLeavesData.getTotalHours());
        leavesAndHolidays.setTotalLeavesDays(totalLeavesData.getTotalDays());

         // Project Summaries

        
        Map<String,Object> ProjectSummaries =
       timesheetFinanceReportService.buildProjectBreakdownForUser(
        userId,
        month,
        year,
        projectDirectory
    );

        
        String employeeName = Optional.ofNullable(allUsers.get(userId))
        .map(u -> (String) u.get("name"))
        .orElse("Unknown User");

         // ✅ Step 6: Calculate total hours (include auto-generated)
        BigDecimal totalHours = timeSheets.stream()
                .map(TimeSheet::getHoursWorked)
                .filter(h -> h != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // 8️⃣ Build DTO
        return MonthlyUserReportDTO.builder()
                .employeeId(userId)
                .employeeName(employeeName)
                .totalHoursWorked(totalHours)
                .billableHours(totalBillableHours)
                .nonBillableHours(totalNonBillableHours)
                .activeProjectsCount(activeProjectsCount)
                .leavesAndHolidays(leavesAndHolidays)
                .weeklySummaryHistory(getWeeklySummaryHistory(userId, month, year))
                .ProjectSummaries(ProjectSummaries)
                
                .dayWiseSummary(dayWiseSummary)
                
                .build();
    }
    public List<WeekSummaryDTO> getWeeklySummaryHistory(Long userId, int month, int year) {
    LocalDate startOfMonth = LocalDate.of(year, month, 1);
    LocalDate endOfMonth = startOfMonth.withDayOfMonth(startOfMonth.lengthOfMonth());

    // Call the existing WeeklySummaryService method
    WeeklySummaryDTO weeklySummaryDTO = weeklySummaryService
            .getUserWeeklyTimeSheetHistoryRange(userId, startOfMonth, endOfMonth);

    // Returns list of weeks with timesheets
    return weeklySummaryDTO.getWeeklySummary();
    }



}
