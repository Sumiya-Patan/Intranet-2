package com.intranet.service;

import com.intranet.entity.*;
import com.intranet.repository.TimeSheetRepo;
import com.intranet.repository.WeekInfoRepo;
import com.intranet.repository.WeeklyTimeSheetReviewRepo;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.math.BigDecimal;
import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class DashboardService {

    private final TimeSheetRepo timeSheetRepo;
    private final WeeklyTimeSheetReviewRepo weeklyReviewRepo;
    private final WeekInfoRepo weekInfoRepo;
    private final RestTemplate restTemplate = new RestTemplate();

    @Value("${pms.api.base-url}")
    private String pmsBaseUrl;

    // üß© Build Auth Headers
    private HttpEntity<Void> buildEntityWithAuth() {
        ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpHeaders headers = new HttpHeaders();
        if (attrs != null) {
            HttpServletRequest request = attrs.getRequest();
            String token = request.getHeader("Authorization");
            if (token != null && !token.isBlank()) headers.set("Authorization", token);
        }
        return new HttpEntity<>(headers);
    }

    // üßæ MAIN SERVICE METHOD
    public Map<String, Object> getDashboardSummary(Long userId, LocalDate startDate, LocalDate endDate) {

        LocalDate today = LocalDate.now();
        if (startDate == null) startDate = today.withDayOfMonth(1);
        if (endDate == null) endDate = today;

        // 1Ô∏è‚É£ Fetch PMS Project Names
        Map<Long, String> projectMap = fetchProjectMap();

        // 2Ô∏è‚É£ Fetch Timesheets
        List<TimeSheet> timeSheets = timeSheetRepo.findByUserIdAndWorkDateBetween(userId, startDate, endDate);
        List<TimeSheetEntry> entries = timeSheets.stream()
                .flatMap(ts -> ts.getEntries().stream())
                .collect(Collectors.toList());

        // 3Ô∏è‚É£ Weekly Review Summary using WeekInfo + WeekTimeSheetReview
        Map<String, Object> weeklyTimesheetReview = getWeeklySummary(userId, startDate, endDate);

        // 4Ô∏è‚É£ Billable Activity
        Map<String, Object> billableActivity = calculateBillableActivity(entries, timeSheets);

        // 5Ô∏è‚É£ Project Summary
        List<Map<String, Object>> projectSummary = calculateProjectSummary(entries, projectMap);

        // 6Ô∏è‚É£ Weekly Summary (Mon‚ÄìSun)
        Map<String, BigDecimal> weeklySummary = calculateWeeklySummary(entries, timeSheets);

        // 7Ô∏è‚É£ Productivity Details
        Map<String, Object> productivityDetails = calculateProductivityDetails(entries);

        // ‚úÖ Step 1: Calculate total from entries
        BigDecimal totalEntryHours = entries.stream()
                .map(e -> e.getHoursWorked() != null ? e.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 2: Add hours from auto-generated timesheets
        BigDecimal totalAutoHours = timeSheets.stream()
                .filter(ts -> Boolean.TRUE.equals(ts.getAutoGenerated()))
                .map(ts -> ts.getHoursWorked() != null ? ts.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 3: Combine both
        BigDecimal totalHours = totalEntryHours.add(totalAutoHours);

        // ‚úÖ Step 4: Format total for display
        totalHours = formatHours(totalHours);


        // üïí Step 1: Count only *manual* (non-auto-generated) timesheets with actual entries
        long totalWorkedDays = timeSheets.stream()
                .filter(ts -> !Boolean.TRUE.equals(ts.getAutoGenerated())) // exclude auto-generated
                .filter(ts -> ts.getEntries() != null && !ts.getEntries().isEmpty()) // exclude empty timesheets
                .map(TimeSheet::getWorkDate)
                .distinct()
                .count();

        // üïí Step 2: Use existing totalHours (which includes auto-generated) for display
        String avgHoursPerDay = calculateAverageHoursPerDay(totalHours, totalWorkedDays);


        // üßæ Final Aggregated Response
        return Map.of(
                "weeklyTimesheetReview", weeklyTimesheetReview,
                "billableActivity", billableActivity,
                "projectSummary", projectSummary,
                "weeklySummary", weeklySummary,
                "productivityDetails", productivityDetails,
                "totalHours", totalHours,
                "averageHoursPerDay", avgHoursPerDay,
                "dateRange", Map.of("startDate", startDate, "endDate", endDate)
        );
    }

    // ‚úÖ Fetch Project Map
    private Map<Long, String> fetchProjectMap() {
        try {
            ResponseEntity<List<Map<String, Object>>> resp = restTemplate.exchange(
                    pmsBaseUrl + "/projects",
                    HttpMethod.GET,
                    buildEntityWithAuth(),
                    new ParameterizedTypeReference<List<Map<String, Object>>>() {}
            );
            if (resp.getBody() == null) return new HashMap<>();

            return resp.getBody().stream()
                    .collect(Collectors.toMap(
                            p -> ((Number) p.get("id")).longValue(),
                            p -> (String) p.get("name"),
                            (a, b) -> a
                    ));
        } catch (Exception e) {
            return new HashMap<>();
        }
    }

        private Map<String, Object> calculateBillableActivity(List<TimeSheetEntry> entries, List<TimeSheet> timeSheets) {
        // ‚úÖ Step 1: Compute total billable and non-billable hours from entries
        BigDecimal billableHours = entries.stream()
                .filter(TimeSheetEntry::isBillable)
                .map(e -> e.getHoursWorked() != null ? e.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal nonBillableHoursFromEntries = entries.stream()
                .filter(e -> !e.isBillable())
                .map(e -> e.getHoursWorked() != null ? e.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // ‚úÖ Step 2: Add auto-generated timesheets as non-billable hours
        BigDecimal autoGeneratedHours = timeSheets.stream()
                .filter(ts -> Boolean.TRUE.equals(ts.getAutoGenerated()))
                .map(ts -> ts.getHoursWorked() != null ? ts.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal totalNonBillableHours = nonBillableHoursFromEntries.add(autoGeneratedHours);

        // ‚úÖ Step 3: Calculate totals and percentages
        BigDecimal totalHours = billableHours.add(totalNonBillableHours);
        double billablePercentage = totalHours.compareTo(BigDecimal.ZERO) == 0
                ? 0.0
                : billableHours.multiply(BigDecimal.valueOf(100))
                        .divide(totalHours, 2, java.math.RoundingMode.HALF_UP)
                        .doubleValue();

        // ‚úÖ Step 4: Build clean response
        return Map.of(
                "billableHours", billableHours,
                "nonBillableHours", totalNonBillableHours,
                "billablePercentage", billablePercentage
        );
        }


    // ‚úÖ Project Summary
    private List<Map<String, Object>> calculateProjectSummary(List<TimeSheetEntry> entries, Map<Long, String> projectMap) {
    Map<Long, BigDecimal> projectHours = entries.stream()
            .filter(e -> e.getProjectId() != null) // ignore missing project entries
            .collect(Collectors.groupingBy(
                    TimeSheetEntry::getProjectId,
                    Collectors.mapping(
                            e -> e.getHoursWorked() == null ? BigDecimal.ZERO : e.getHoursWorked(), // ‚úÖ handle nulls
                            Collectors.reducing(BigDecimal.ZERO, BigDecimal::add)
                    )
            ));

    return projectHours.entrySet().stream().map(e -> {
        Map<String, Object> m = new HashMap<>();
        m.put("projectId", e.getKey());
        m.put("projectName", projectMap.getOrDefault(e.getKey(), "Unknown Project"));
        m.put("totalHoursWorked", formatHours(e.getValue()));
        return m;
    }).collect(Collectors.toList());
    }


    // ‚úÖ Weekly Summary (hours by weekday)
        private Map<String, BigDecimal> calculateWeeklySummary(List<TimeSheetEntry> entries, List<TimeSheet> timeSheets) {
        // ‚úÖ Step 1: Initialize map for all weekdays (Mon‚ÄìSun)
        Map<String, BigDecimal> weeklySummary = Arrays.stream(DayOfWeek.values())
                .collect(Collectors.toMap(
                        d -> d.name().toLowerCase(),
                        d -> BigDecimal.ZERO,
                        (a, b) -> a,
                        LinkedHashMap::new
                ));

        // ‚úÖ Step 2: Add hours from normal timesheet entries
        for (TimeSheetEntry entry : entries) {
                if (entry == null || entry.getTimeSheet() == null || entry.getTimeSheet().getWorkDate() == null)
                continue;

                LocalDate workDate = entry.getTimeSheet().getWorkDate();
                BigDecimal hours = entry.getHoursWorked() != null ? entry.getHoursWorked() : BigDecimal.ZERO;

                String dayKey = workDate.getDayOfWeek().name().toLowerCase();
                weeklySummary.merge(dayKey, hours, BigDecimal::add);
        }

        // ‚úÖ Step 3: Add hours from auto-generated timesheets (no entries)
        for (TimeSheet ts : timeSheets) {
                if (Boolean.TRUE.equals(ts.getAutoGenerated()) && ts.getWorkDate() != null) {
                String dayKey = ts.getWorkDate().getDayOfWeek().name().toLowerCase();
                BigDecimal hours = ts.getHoursWorked() != null ? ts.getHoursWorked() : BigDecimal.ZERO;
                weeklySummary.merge(dayKey, hours, BigDecimal::add);
                }
        }

        // ‚úÖ Step 4: Format all totals (e.g., 8.00 ‚Üí consistent decimal form)
        weeklySummary.replaceAll((k, v) -> formatHours(v == null ? BigDecimal.ZERO : v));

        return weeklySummary;
        }


    // ‚úÖ Productivity Details (by day)
    private Map<String, Object> calculateProductivityDetails(List<TimeSheetEntry> entries) {
    Map<String, List<TimeSheetEntry>> dayWise = entries.stream()
            .collect(Collectors.groupingBy(
                    e -> e.getTimeSheet() != null && e.getTimeSheet().getWorkDate() != null
                            ? e.getTimeSheet().getWorkDate().getDayOfWeek().name().toLowerCase()
                            : "unknown"
            ));

    Map<String, Object> productivity = new LinkedHashMap<>();

    for (DayOfWeek day : DayOfWeek.values()) {
        List<TimeSheetEntry> dayEntries = dayWise.getOrDefault(day.name().toLowerCase(), new ArrayList<>());

        // ‚úÖ Handle null hours safely
        BigDecimal totalHours = dayEntries.stream()
                .map(e -> e.getHoursWorked() != null ? e.getHoursWorked() : BigDecimal.ZERO)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        long billableCount = dayEntries.stream().filter(TimeSheetEntry::isBillable).count();
        long totalCount = dayEntries.size();
        double billablePercentage = totalCount == 0 ? 0.0 : (billableCount * 100.0 / totalCount);

        long tasksWorked = dayEntries.stream()
                .map(TimeSheetEntry::getTaskId)
                .filter(Objects::nonNull)
                .distinct()
                .count();

        long projectsWorked = dayEntries.stream()
                .map(TimeSheetEntry::getProjectId)
                .filter(Objects::nonNull)
                .distinct()
                .count();

        double productivityScore = Math.min(100.0, billablePercentage + (tasksWorked * 2) + (projectsWorked * 3));

        productivity.put(day.name().toLowerCase(), Map.of(
                "totalHours", formatHours(totalHours == null ? BigDecimal.ZERO : totalHours),
                "billablePercentage", round(billablePercentage, 1),
                "tasksWorked", tasksWorked,
                "projectsWorked", projectsWorked,
                "productivityScore", round(productivityScore, 1)
        ));
    }

    return productivity;
    }


    // ‚úÖ Week-based Review Summary (using WeekInfo & WeekTimeSheetReview)
    public Map<String, Object> getWeeklySummary(Long userId, LocalDate startDate, LocalDate endDate) {

    // 1Ô∏è‚É£ Fetch all week ranges between start and end date
    List<WeekInfo> allWeeks = weekInfoRepo.findByStartDateBetween(startDate, endDate);

    // 2Ô∏è‚É£ Fetch only the existing weekly reviews for this user
    List<WeeklyTimeSheetReview> reviews =
            weeklyReviewRepo.findByUserIdAndWeekInfo_StartDateBetween(userId, startDate, endDate);

    // 3Ô∏è‚É£ Map weekId ‚Üí list of statuses
    Map<Long, List<WeeklyTimeSheetReview.Status>> reviewMap = reviews.stream()
            .collect(Collectors.groupingBy(
                    r -> r.getWeekInfo().getId(),
                    Collectors.mapping(WeeklyTimeSheetReview::getStatus, Collectors.toList())
            ));

    long submitted = 0, approved = 0, rejected = 0, notSubmitted = 0;

    // 4Ô∏è‚É£ Loop through all week infos (including those without reviews)
    for (WeekInfo week : allWeeks) {
        List<WeeklyTimeSheetReview.Status> statuses = reviewMap.get(week.getId());

        if (statuses == null || statuses.isEmpty()) {
            notSubmitted++;
        } else if (statuses.contains(WeeklyTimeSheetReview.Status.REJECTED)) {
            rejected++;
        } else if (statuses.stream().allMatch(s -> s == WeeklyTimeSheetReview.Status.APPROVED)) {
            approved++;
        } else {
            submitted++;
        }
    }

    // 5Ô∏è‚É£ Return only summary counts
    return Map.of(
            "submittedWeeks", submitted,
            "approvedWeeks", approved,
            "rejectedWeeks", rejected,
            "notSubmittedWeeks", notSubmitted
    );
    }


    // ‚úÖ Utility Helpers
    private BigDecimal formatHours(BigDecimal value) {
        String str = value.toPlainString();
        String[] parts = str.split("\\.");
        int hours = Integer.parseInt(parts[0]);
        int mins = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;
        if (mins >= 60) {
            hours += mins / 60;
            mins %= 60;
        }
        return new BigDecimal(String.format("%02d.%02d", hours, mins));
    }

    private String calculateAverageHoursPerDay(BigDecimal totalHours, long totalDays) {
        if (totalDays == 0 || totalHours.compareTo(BigDecimal.ZERO) <= 0) return "00:00";
        String[] parts = totalHours.toPlainString().split("\\.");
        int hours = Integer.parseInt(parts[0]);
        int mins = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;
        long totalMinutes = (hours * 60L) + mins;
        long avgMinutes = totalMinutes / totalDays;
        return String.format("%02d:%02d", avgMinutes / 60, avgMinutes % 60);
    }

    private double round(double value, int places) {
        return Math.round(value * Math.pow(10, places)) / Math.pow(10, places);
    }
}
